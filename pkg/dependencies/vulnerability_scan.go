package dependencies

import (
	"context"
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"strings"
	"time"

	"github.com/fulmenhq/goneat/pkg/logger"
	"github.com/fulmenhq/goneat/pkg/sbom"
	"github.com/fulmenhq/goneat/pkg/vulnerabilities"
	"gopkg.in/yaml.v3"
)

type VulnerabilityPolicy struct {
	Enabled        bool
	Tool           string
	FailOn         string
	IgnoreUnfixed  bool
	Allow          []VulnerabilityAllow
	RemediationAge map[string]int
	CoolingDays    map[string]int
}

type VulnerabilityAllow struct {
	ID           string
	Until        string
	Reason       string
	ApprovedBy   string
	ApprovedDate string
	Ticket       string
}

type VulnerabilityScanResult struct {
	ReportPath    string
	RawReportPath string
	Summary       vulnerabilities.Summary
	PackageCount  int // Number of packages scanned (from SBOM)
}

func RunVulnerabilityScan(ctx context.Context, target string, policyPath string, sbomInputPath string, timeout time.Duration) (*VulnerabilityScanResult, []Issue, error) {
	policy, err := loadVulnerabilityPolicy(policyPath)
	if err != nil {
		return nil, nil, err
	}

	// If no vulnerabilities config exists, use sensible defaults
	// This allows `--vuln` to work without explicit configuration
	if policy == nil {
		logger.Info("dependencies: no vulnerabilities config found, using defaults (enabled=true, fail_on=none)")
		policy = &VulnerabilityPolicy{
			Enabled:       true,
			Tool:          "grype",
			FailOn:        "none",
			IgnoreUnfixed: false,
		}
	}

	if !policy.Enabled {
		logger.Debug("dependencies: vulnerability scanning disabled in config")
		return nil, nil, nil
	}

	if policy.Tool == "" {
		policy.Tool = "grype"
	}

	absTarget, err := filepath.Abs(target)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to resolve target: %w", err)
	}

	timestamp := time.Now().Format("20060102-150405")
	sbomPath := filepath.Join(absTarget, "sbom", fmt.Sprintf("goneat-%s.cdx.json", timestamp))
	grypeRawPath := filepath.Join(absTarget, "sbom", fmt.Sprintf("vuln-%s.grype.json", timestamp))
	normalizedPath := filepath.Join(absTarget, "sbom", fmt.Sprintf("vuln-%s.json", timestamp))

	var sbomSource string
	var packageCount int
	if strings.TrimSpace(sbomInputPath) != "" {
		candidate := filepath.Clean(sbomInputPath)
		if !filepath.IsAbs(candidate) {
			candidate = filepath.Join(absTarget, candidate)
		}
		if _, err := os.Stat(candidate); err != nil {
			return nil, nil, fmt.Errorf("sbom input not found: %w", err)
		}
		sbomSource = candidate
		// packageCount remains 0 when using existing SBOM (could parse it, but not critical)
	} else {
		sbomInvoker, err := sbom.NewSyftInvoker()
		if err != nil {
			return nil, nil, fmt.Errorf("syft not available: %w", err)
		}
		sbomResult, err := sbomInvoker.Generate(ctx, sbom.Config{
			TargetPath: absTarget,
			OutputPath: sbomPath,
			Format:     "cyclonedx-json",
		})
		if err != nil {
			return nil, nil, fmt.Errorf("sbom generation failed: %w", err)
		}
		sbomSource = sbomResult.OutputPath
		packageCount = sbomResult.PackageCount
	}

	grypeInvoker, err := vulnerabilities.NewGrypeInvoker()
	if err != nil {
		return nil, nil, fmt.Errorf("grype not available: %w", err)
	}

	raw, grypeVersion, err := grypeInvoker.ScanSBOM(ctx, sbomSource, grypeRawPath, timeout)
	if err != nil {
		return nil, nil, err
	}

	findings, counts, err := vulnerabilities.ParseGrype(raw)
	if err != nil {
		return nil, nil, fmt.Errorf("failed to parse grype output: %w", err)
	}

	matchCount := 0
	for _, v := range counts {
		matchCount += v
	}
	summary := vulnerabilities.Summary{
		MatchCount: matchCount,
		Counts:     counts,
	}

	issues := evaluateVulnerabilityPolicy(policy, &findings, &summary)

	report := vulnerabilities.Report{
		Version:     "v1",
		GeneratedAt: time.Now(),
		Target:      absTarget,
		Tool:        "grype",
		ToolVersion: strings.TrimSpace(grypeVersion),
		SBOMPath:    sbomSource,
		RawPath:     grypeRawPath,
		Summary:     summary,
		Findings:    findings,
	}

	data, err := json.MarshalIndent(report, "", "  ")
	if err != nil {
		return nil, nil, fmt.Errorf("failed to marshal vulnerability report: %w", err)
	}
	if err := os.WriteFile(normalizedPath, data, 0o600); err != nil {
		return nil, nil, fmt.Errorf("failed to write vulnerability report: %w", err)
	}

	logger.Info("dependencies: vulnerability report generated", logger.String("path", normalizedPath))

	issues = append([]Issue{{
		Type:     "vulnerability",
		Severity: "info",
		Message: fmt.Sprintf(
			"Vulnerability report generated: %s (critical=%d high=%d medium=%d low=%d unknown=%d)",
			filepath.ToSlash(normalizedPath),
			counts[vulnerabilities.SeverityCritical],
			counts[vulnerabilities.SeverityHigh],
			counts[vulnerabilities.SeverityMedium],
			counts[vulnerabilities.SeverityLow],
			counts[vulnerabilities.SeverityUnknown],
		),
	}}, issues...)

	return &VulnerabilityScanResult{ReportPath: normalizedPath, RawReportPath: grypeRawPath, Summary: summary, PackageCount: packageCount}, issues, nil
}

// rawFindingsCount was used during early prototyping and is intentionally removed.

func loadVulnerabilityPolicy(policyPath string) (*VulnerabilityPolicy, error) {
	data, err := os.ReadFile(policyPath) // #nosec G304 -- policyPath is user-specified config file, intentional for CLI tool
	if err != nil {
		return nil, nil
	}
	var raw map[string]interface{}
	if err := yaml.Unmarshal(data, &raw); err != nil {
		return nil, fmt.Errorf("failed to parse dependencies policy: %w", err)
	}
	vulnRaw, ok := raw["vulnerabilities"].(map[string]interface{})
	if !ok {
		return nil, nil
	}
	enabled, _ := vulnRaw["enabled"].(bool)
	if !enabled {
		return &VulnerabilityPolicy{Enabled: false}, nil
	}
	tool, _ := vulnRaw["tool"].(string)
	failOn, _ := vulnRaw["fail_on"].(string)
	if failOn == "" {
		failOn = "none"
	}
	ignoreUnfixed, _ := vulnRaw["ignore_unfixed"].(bool)

	allow := []VulnerabilityAllow{}
	if allowList, ok := vulnRaw["allow"].([]interface{}); ok {
		for _, item := range allowList {
			m, ok := item.(map[string]interface{})
			if !ok {
				continue
			}
			entry := VulnerabilityAllow{}
			entry.ID, _ = m["id"].(string)
			entry.Until, _ = m["until"].(string)
			entry.Reason, _ = m["reason"].(string)
			entry.ApprovedBy, _ = m["approved_by"].(string)
			entry.ApprovedDate, _ = m["approved_date"].(string)
			entry.Ticket, _ = m["ticket"].(string)
			if entry.ID != "" {
				allow = append(allow, entry)
			}
		}
	}

	coolingDays := map[string]int{}
	if cd, ok := vulnRaw["cooling_days"].(map[string]interface{}); ok {
		for k, v := range cd {
			if i, ok := asInt(v); ok {
				coolingDays[k] = i
			}
		}
	}

	remediationAge := map[string]int{}
	if ra, ok := vulnRaw["remediation_age"].(map[string]interface{}); ok {
		if enabled, _ := ra["enabled"].(bool); enabled {
			if md, ok := ra["max_days"].(map[string]interface{}); ok {
				for k, v := range md {
					if i, ok := asInt(v); ok {
						remediationAge[k] = i
					}
				}
			}
		}
	}

	return &VulnerabilityPolicy{
		Enabled:        true,
		Tool:           tool,
		FailOn:         strings.ToLower(strings.TrimSpace(failOn)),
		IgnoreUnfixed:  ignoreUnfixed,
		Allow:          allow,
		CoolingDays:    coolingDays,
		RemediationAge: remediationAge,
	}, nil
}

func evaluateVulnerabilityPolicy(policy *VulnerabilityPolicy, findings *[]vulnerabilities.Finding, summary *vulnerabilities.Summary) []Issue {
	if policy == nil || !policy.Enabled {
		return nil
	}

	allowed := map[string]VulnerabilityAllow{}
	for _, a := range policy.Allow {
		allowed[strings.TrimSpace(a.ID)] = a
	}

	// NOTE: When fail_on is "none", we still compute a threshold but will short-circuit
	// later (no enforcement). This keeps the logic centralized and avoids special-casing.
	var threshold vulnerabilities.Severity
	switch policy.FailOn {
	case "none", "":
		threshold = vulnerabilities.SeverityCritical
	case "any":
		threshold = vulnerabilities.SeverityLow
	case "low":
		threshold = vulnerabilities.SeverityLow
	case "medium":
		threshold = vulnerabilities.SeverityMedium
	case "high":
		threshold = vulnerabilities.SeverityHigh
	case "critical":
		threshold = vulnerabilities.SeverityCritical
	default:
		threshold = vulnerabilities.SeverityCritical
	}

	issues := []Issue{}
	violations := 0
	suppressed := 0
	thresholdLabel := policy.FailOn
	if thresholdLabel == "" {
		thresholdLabel = "critical"
	}

	for i := range *findings {
		f := &(*findings)[i]
		if allowEntry, ok := allowed[f.ID]; ok {
			shouldAllow := true
			if strings.TrimSpace(allowEntry.Until) != "" {
				if t, err := time.Parse("2006-01-02", allowEntry.Until); err == nil {
					if time.Now().After(t) {
						shouldAllow = false
					}
				}
			}
			if shouldAllow {
				f.Suppressed = true
				f.SuppressReason = allowEntry.Reason
				suppressed++
				continue
			}
		}

		if policy.IgnoreUnfixed {
			if len(f.FixVersions) == 0 {
				f.Suppressed = true
				f.SuppressReason = "ignore_unfixed"
				suppressed++
				continue
			}
		}

		maxDays := 0
		if len(policy.RemediationAge) > 0 {
			maxDays = policy.RemediationAge[string(f.Severity)]
		}
		if maxDays == 0 && len(policy.CoolingDays) > 0 {
			maxDays = policy.CoolingDays[string(f.Severity)]
		}

		if maxDays > 0 {
			date := strings.TrimSpace(f.PublishedDate)
			if date == "" {
				date = strings.TrimSpace(f.FixFirstSeen)
			}
			if date == "" {
				f.Suppressed = true
				f.SuppressReason = "remediation_age_unknown"
				suppressed++
				continue
			}
			if t, err := time.Parse("2006-01-02", date); err == nil {
				ageDays := int(time.Since(t).Hours() / 24)
				if ageDays <= maxDays {
					f.Suppressed = true
					f.SuppressReason = fmt.Sprintf("within_remediation_age_%dd", maxDays)
					suppressed++
					continue
				}
			}
		}

		if policy.FailOn == "none" {
			continue
		}

		if vulnerabilities.SeverityMeetsOrExceeds(f.Severity, threshold) {
			violations++
			issues = append(issues, Issue{
				Type:     "vulnerability",
				Severity: string(f.Severity),
				Message:  fmt.Sprintf("%s: %s affects %d package(s)", f.ID, f.Severity, f.PackageCount),
			})
		}
	}

	summary.Violations = violations
	summary.Suppressed = suppressed

	if violations > 0 && policy.FailOn != "none" {
		issues = append([]Issue{{
			Type:     "vulnerability",
			Severity: "critical",
			Message:  fmt.Sprintf("vulnerability policy failed: %d finding(s) at or above %s", violations, thresholdLabel),
		}}, issues...)
	}

	return issues
}
