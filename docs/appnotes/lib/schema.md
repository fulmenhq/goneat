---
title: Schema Validation Library
description: Reusable validators for JSON/YAML using goneat's embedded assets.
---

# Schema Validation

Goneat's `pkg/schema` package wraps [gojsonschema](https://github.com/xeipuuv/gojsonschema) to make JSON/YAML schema
validation easy across CLI tools and Go applications. The library focuses on three scenarios:

1. **Embedded schemas** – validate data against the schemas shipped with goneat (for example `goneat-config-v1.0.0`).
2. **One-off schemas** – compile a validator from in-memory bytes or `fs.FS` (handy with `go:embed`).
3. **Meta validation** – lint schema files themselves against the Draft-07 or 2020‑12 meta-schemas.

The code below highlights the new validator API delivered in v0.2.9.

## Embedded schema validation

```go
package main

import (
    "fmt"

    "github.com/fulmenhq/goneat/pkg/schema"
)

func main() {
    validator, err := schema.GetEmbeddedValidator("goneat-config-v1.0.0")
    if err != nil {
        panic(err)
    }

    data := map[string]any{
        "format": map[string]any{"go": map[string]any{"simplify": true}},
        "security": map[string]any{"timeout": "5m"},
    }

    result, err := validator.Validate(data)
    if err != nil {
        panic(err)
    }
    fmt.Printf("valid? %v\n", result.Valid)
}
```

## Compile from bytes or fs.FS

```go
package main

import (
    "embed"
    "log"

    "github.com/fulmenhq/goneat/pkg/schema"
)

//go:embed schemas/user-profile.json
var embeddedSchemas embed.FS

func main() {
    validator, err := schema.NewValidatorFromFS(embeddedSchemas, "schemas/user-profile.json")
    if err != nil {
        log.Fatal(err)
    }

    payload := map[string]any{"name": "Ava", "age": 30}
    result, err := validator.Validate(payload)
    if err != nil {
        log.Fatal(err)
    }

    if !result.Valid {
        log.Fatalf("invalid payload: %+v", result.Errors)
    }
}
```

The helper also accepts raw bytes: `schema.NewValidatorFromBytes(schemaJSON)`.

## Meta validation for schema files

```go
validator, err := schema.NewValidatorFromMetaSchema("draft-07")
if err != nil {
    panic(err)
}

schemaBytes := os.ReadFile("./schemas/project.json")
result, err := validator.ValidateBytes(schemaBytes)
if err != nil {
    panic(err)
}
if !result.Valid {
    for _, e := range result.Errors {
        log.Printf("schema issue: %s", e.Message)
    }
}
```

This is the same logic the `goneat schema validate-schema` CLI command uses.

## Working with results

Every validation entry point returns a `*schema.Result`:

```go
type Result struct {
    Valid  bool
    Errors []schema.ValidationError
}

type ValidationError struct {
    Path    string
    Message string
    Context schema.ValidationContext // optional
}
```

`Result.Valid` is `false` when one or more errors exist. Each error carries a JSON pointer-like `Path` and the human
readable message supplied by gojsonschema.

## Related commands

- **CLI**: `goneat schema validate-schema` meta-validates schema files using these helpers.
- **CLI**: `goneat schema validate-data` validates data against embedded schemas or schema files.
- **Assess category**: the `schema` assessment runner uses the same primitives to report issues during `goneat assess`.

Generated by Arch Eagle ([Codex CLI](https://github.com/openai/codex)) under supervision of [@3leapsdave](https://github.com/3leapsdave)
