# Goneat v0.3.6 — Package Manager Installation & Tools Cooling Policy

**Release Date**: 2025-11-12
**Status**: Release

## TL;DR

- **Package Manager Installation**: Complete implementation of package manager-based tool installation (Homebrew, Scoop)
- **Tools Cooling Policy**: Supply chain security enforcement for external tool installation with configurable age/download thresholds
- **Schema v1.1.0**: Full execution of declarative package manager installs and cooling policy configuration
- **Doctor Integration**: Package manager status display, installation verification, and cooling policy enforcement
- **Cross-Platform**: Native support for macOS/Linux (brew) and Windows (scoop)
- **Example Manifests**: Ready-to-use configuration examples for brew formula, brew cask, scoop, and cooling overrides

## What's New

### Package Manager Installation Engine

Completes the package manager installation feature introduced in v0.3.4 (schema-only). Tools can now be installed declaratively via Homebrew (macOS/Linux) or Scoop (Windows) using structured configuration.

**Example Configuration** (`.goneat/tools.yaml`):

```yaml
tools:
  goneat:
    name: goneat
    kind: system
    description: "Fulmen CLI for neat code workflows"
    detect_command: "goneat --version"
    install:
      type: package_manager
      package_manager:
        manager: brew
        tap: fulmenhq/homebrew-tap
        package: fulmenhq/tap/goneat
        package_type: formula
        flags: ["--quiet"]
```

**Usage**:

```bash
# Check package manager availability
goneat doctor tools --scope foundation

# Dry-run to see what would be installed
goneat doctor tools --config .goneat/tools.yaml --dry-run

# Install tools via package manager
goneat doctor tools --config .goneat/tools.yaml --install --yes
```

### Key Features

#### 1. Platform-Aware Detection
- Automatically detects Homebrew (macOS/Linux) or Scoop (Windows)
- Version parsing for installed package managers
- Clear status reporting with installation URLs for missing managers

#### 2. Brew Installer
- **Tap Support**: Automatically adds custom taps (e.g., `fulmenhq/homebrew-tap`)
- **Formula & Cask**: Install CLI tools (formula) or GUI apps (cask)
- **Custom Flags**: Pass additional flags like `--quiet`, `--force`
- **Idempotent**: Safe to run multiple times

#### 3. Scoop Installer
- **Bucket Support**: Automatically adds custom buckets (e.g., `extras`)
- **Custom Flags**: Pass flags like `--no-cache`, `--global`
- **Windows Native**: First-class Windows package management

#### 4. Doctor Command Integration
- Package manager status shown before tool checks
- Clear remediation when managers not available
- `--install-package-managers` flag (shows manual installation instructions)

#### 5. Dry-Run Mode
```bash
goneat doctor tools --config .goneat/examples/tools-brew-formula.yaml --dry-run
```
Shows what commands would execute without making changes.

### Example Manifests

Three ready-to-use examples included in `.goneat/examples/`:

1. **tools-brew-formula.yaml**: CLI tools via Homebrew formulas (jq, ripgrep, goneat)
2. **tools-brew-cask.yaml**: GUI applications via Homebrew casks (Docker Desktop, VS Code)
3. **tools-scoop.yaml**: Windows tools via Scoop (ripgrep, jq, git)

**Validate Examples**:
```bash
goneat doctor tools --config .goneat/examples/tools-brew-formula.yaml --validate-config
```

### Implementation Phases

This release completes Phases 2-6 of the package manager feature:

- **Phase 1** (v0.3.4): Schema v1.1.0 with `install.type: package_manager` support
- **Phase 2** (v0.3.6): Detection layer with BrewManager/ScoopManager (261 LOC)
- **Phase 3** (v0.3.6): Installer implementations for brew/scoop (326 LOC)
- **Phase 4** (v0.3.6): Doctor command integration with status display
- **Phase 5** (v0.3.6): Documentation and example manifests
- **Phase 6** (v0.3.6): Comprehensive test coverage (32 new tests, 953 LOC)

### Technical Details

**Files Added**:
- `pkg/tools/package_managers.go`: Detection and status reporting
- `pkg/tools/installer_brew.go`: Homebrew installer implementation
- `pkg/tools/installer_scoop.go`: Scoop installer implementation
- `pkg/tools/package_managers_test.go`: Detection tests (503 LOC)
- `pkg/tools/installer_brew_test.go`: Brew installer tests (231 LOC)
- `pkg/tools/installer_scoop_test.go`: Scoop installer tests (219 LOC)
- `.goneat/examples/`: Example manifests + README

**Files Modified**:
- `pkg/tools/installer.go`: Added InstallWithPackageManager factory
- `pkg/tools/installer_test.go`: Added integration tests
- `cmd/doctor.go`: Package manager status display
- `internal/doctor/tools.go`: Status API forwarding

**Backward Compatibility**: v1.0.0 manifests with `install_commands` continue to work. The schema change is additive (minor version bump).

### Tools Cooling Policy (Supply Chain Security)

Blocks installation of newly-published external tools until they meet minimum age and download thresholds, protecting against supply chain attacks where malicious actors publish or compromise tool releases.

**Why It Matters**: 80% of supply chain attacks are detected within the first 7 days of package publication. Recent attacks on popular tools demonstrate the risk of adopting freshly-published releases.

**Example Configuration** (`.goneat/dependencies.yaml` - global policy):

```yaml
version: v1
cooling:
  enabled: true
  min_age_days: 7              # Require tools to be ≥7 days old
  min_downloads: 100           # Require ≥100 total downloads
  min_downloads_recent: 10     # Require ≥10 recent downloads
  alert_only: false            # Block installation (not just warn)
  grace_period_days: 3         # 3-day grace for initial publication
  exceptions:
    - pattern: "github.com/fulmenhq/*"
      reason: "Internal packages are pre-vetted"
      approved_by: "@3leapsdave"
```

**Tool-Specific Overrides** (`.goneat/tools.yaml` - risk-based policies):

```yaml
tools:
  syft:
    name: syft
    description: "SBOM generation tool"
    cooling:
      min_age_days: 14         # Stricter for critical SBOM tool
      min_downloads: 5000      # Higher threshold for supply chain tool
      min_downloads_recent: 100
```

**Usage**:

```bash
# Check tools with cooling policy enforcement
goneat doctor tools --scope foundation

# Install with cooling checks (blocks new releases)
goneat doctor tools --scope foundation --install --yes

# Bypass cooling for offline/air-gapped environments
goneat doctor tools --scope foundation --install --no-cooling
```

### Key Features

#### 1. 3-Level Configuration Hierarchy

Policy resolution follows this precedence:

1. **CLI Flag** (`--no-cooling`) - Disables for this run
2. **Tool-Specific** (`.goneat/tools.yaml`) - Per-tool overrides
3. **Global Default** (`.goneat/dependencies.yaml`) - Organization-wide policy

Example hierarchy in action:
- `syft`: 14 days / 5000 downloads (tool-specific override)
- `ripgrep`: 7 days / 100 downloads (global default)
- `jq`: 7 days / 100 downloads (global default)
- With `--no-cooling`: All checks disabled for this run

#### 2. GitHub Releases API Integration

- Fetches release metadata (publish date, download counts) from GitHub Releases API
- 24-hour caching layer minimizes rate-limit risk
- Automatic fallback to latest release when tool version not specified
- Repository auto-detection from artifact URLs and common tool name patterns
- Rate limit parsing with clear "retry in X minutes" messaging

#### 3. Alert-Only Mode

For gradual adoption or monitoring:

```yaml
cooling:
  enabled: true
  alert_only: true  # Warn but don't block installation
```

Useful for:
- Pilot deployments to measure policy impact
- Teams transitioning from no policy to strict enforcement
- Development environments where cooling is informational

#### 4. Offline Support

Use `--no-cooling` flag for:
- Air-gapped environments without GitHub API access
- CI/CD pipelines with network restrictions
- Emergency deployments requiring immediate tool adoption

### Technical Details

**Files Added**:
- `pkg/tools/metadata/registry.go`: Metadata fetching registry with caching
- `pkg/tools/metadata/cache.go`: 24-hour TTL cache implementation
- `pkg/tools/metadata/github.go`: GitHub Releases API client
- `pkg/tools/metadata/errors.go`: Structured error types
- `internal/doctor/cooling.go`: Cooling policy enforcement
- `pkg/tools/config.go`: CoolingConfig structs and inheritance logic
- Comprehensive test coverage (515 LOC across metadata and config tests)

**Files Modified**:
- `cmd/doctor.go`: Added `--no-cooling` flag and enforcement integration
- `internal/doctor/tools.go`: Extended Tool struct with cooling config
- `schemas/tools/v1.1.0/tools-config.yaml`: Added `cooling` field to schema

**Documentation**:
- Enhanced `docs/guides/package-cooling-policy.md` with tool-specific overrides
- Updated `docs/appnotes/dogfooding-dependency-protection.md` with hierarchy examples
- Living example in `.goneat/tools.yaml` (syft with stricter policy)

### Use Cases

**Critical SBOM Tools** (stricter policy):
```yaml
syft:
  cooling:
    min_age_days: 14
    min_downloads: 5000
```
SBOM tools document your entire supply chain - compromised SBOM tooling could hide vulnerabilities.

**Standard CLI Tools** (use global defaults):
Tools like `ripgrep`, `jq`, `golangci-lint` use organization-wide policy (typically 7 days).

**Low-Risk Tools** (disable cooling):
```yaml
local-dev-tool:
  cooling:
    enabled: false
```
For non-production tools or when risk is acceptable.

## What's Fixed

### Platform Filtering for Doctor Tools

Fixed a critical bug where `goneat doctor tools` was incorrectly checking platform-specific tools on incompatible platforms, causing false failures in multi-platform CI/CD pipelines.

**Problem**: When using shared tool configurations across platforms (common in template repositories and CI/CD), Windows-only tools like `scoop` were reported as "missing" on macOS/Linux, and Unix-only tools like `mise` were reported as "missing" on Windows. This caused `goneat doctor tools` to exit with code 1 even when all platform-applicable tools were present.

**Root Cause**: The `GetToolsForScope()` function returned all tools in a scope without filtering by platform. Tools with `platforms: ["windows"]` were checked on all platforms, leading to false "missing tool" errors.

**Solution**: Added platform filtering before checking tools in all doctor modes:

- **New Helper Function**: `SupportsCurrentPlatform()` checks if a tool is applicable to the current platform
- **Platform Matching**:
  - Empty `platforms` list = supports all platforms (no restriction)
  - `*` or `all` in list = supports all platforms (explicit wildcard)
  - Otherwise, current platform must be explicitly listed
- **Applied to All Modes**: check, install, dry-run, check-updates

**Impact**:

- ✅ **Multi-Platform CI/CD**: Shared tool configs now work across different runner platforms
- ✅ **Template Repositories**: Bootstrap scripts with platform-specific tools no longer fail
- ✅ **Make Targets**: `make bootstrap` commands succeed on all supported platforms

**Example**:

```yaml
# .goneat/tools.yaml (shared across platforms)
scopes:
  bootstrap:
    tools: ["curl", "scoop", "mise"]

tools:
  curl:
    platforms: ["darwin", "linux", "windows"]  # All platforms
  scoop:
    platforms: ["windows"]  # Windows-only
  mise:
    platforms: ["darwin", "linux"]  # Unix-only
```

**Before Fix** (on macOS):
```bash
goneat doctor tools --scope bootstrap
# ERROR: scoop missing (incorrectly checked on macOS)
# EXIT: 1 (failure)
```

**After Fix** (on macOS):
```bash
goneat doctor tools --scope bootstrap
# INFO: curl present
# INFO: mise present
# DEBUG: Skipping scoop (not applicable to darwin platform)
# EXIT: 0 (success)
```

**Test Coverage**: 12 unit tests covering platform matching scenarios, plus integration test for the bug scenario.

**Files Modified**:
- `internal/doctor/tools.go`: Added `SupportsCurrentPlatform()` helper (35 LOC)
- `cmd/doctor.go`: Applied filtering to all tool check modes (4 locations)
- `internal/doctor/tools_test.go`: Platform filtering unit tests (198 LOC)
- `cmd/doctor_test.go`: Integration test for bug scenario

### Manual Installer Execution

Fixed a critical bug where manual installers were never executed, blocking package manager bootstrap workflows.

**Problem**: The manual installer kind was designed for bootstrapping package managers (mise, scoop) via official install scripts, but `isInstallerAvailable()` returned `false` for `installerManual`, causing these commands to be skipped entirely.

**Root Cause**: Manual installer was treated like other installers that require a package manager to be present. However, manual installers are just scripts/commands to execute and don't have prerequisites.

**Solution**: Changed `isInstallerAvailable()` to return `true` for `installerManual`, treating it as always available.

**Impact**:
- ✅ **CI/CD Bootstrap**: Automated workflows can now bootstrap package managers from scratch
- ✅ **Template Repositories**: Projects can include package manager bootstrap in their tool configs
- ✅ **Fresh Workstations**: Onboarding developers can run `goneat doctor tools --scope bootstrap --install` to auto-setup

**Example Configuration**:

```yaml
# .goneat/tools.yaml (bootstrap scope)
tools:
  mise:
    name: "mise"
    description: "Polyglot runtime manager"
    kind: "system"
    detect_command: "mise --version"
    platforms: ["linux", "darwin"]
    installer_priority:
      linux: ["manual"]
      darwin: ["manual"]
    install_commands:
      manual: |
        curl https://mise.jdx.dev/install.sh | sh && \
        echo 'Add $HOME/.local/bin to PATH'
```

**Usage**:

```bash
# Automatically bootstrap mise if missing
goneat doctor tools --scope bootstrap --install --yes

# Verify installation
mise --version

# Add to PATH for persistence
export PATH="$HOME/.local/bin:$PATH"
```

**Test Coverage**: 3 new unit tests for manual installer availability + integration test for bootstrap scenario.

**Files Modified**:
- `internal/doctor/tools.go`: Fixed `isInstallerAvailable()` for manual installer (3 LOC)
- `internal/doctor/tools_test.go`: Manual installer unit tests (155 LOC)
- `cmd/doctor_test.go`: Bootstrap integration test (48 LOC)

### Install Commands Documentation Clarification

Fixed misleading documentation that caused widespread confusion about `install_commands` syntax.

**Problem**: Documentation and examples showed `install_commands` using platform keys (`linux:`, `darwin:`, `windows:`), but the code only recognizes **installer-kind keys** (`mise`, `brew`, `apt-get`, `manual`, etc.). Platform keys were silently ignored, causing tools to never install.

**Root Cause**: Historical documentation carried over platform key examples when the feature was originally designed differently. The code evolved to use installer-kind keys for flexibility, but docs weren't updated.

**Solution**:

1. **Code Validation**: Added `ValidateInstallerCommands()` function that warns when:
   - Platform keys (linux, darwin, windows) are used instead of installer-kind keys
   - Unknown/unrecognized keys are used

2. **Documentation Updates**: Fixed all examples in:
   - `docs/appnotes/lib/tools.md` - Added comprehensive "Understanding Installer Kinds vs Platforms" section
   - `docs/appnotes/tools-runner-usage.md` - Fixed all examples to use installer-kind keys with priority fallbacks
   - `docs/user-guide/bootstrap/package-managers.md` - Added automatic bootstrap section with v0.3.6 examples

**Example Warnings**:

```bash
# User config with platform keys (WRONG):
tools:
  ripgrep:
    install_commands:
      linux: "apt-get install ripgrep"  # This is ignored!

# Warning output:
WARN Tool ripgrep: install_commands key 'linux' looks like a platform.
     Use installer-kind keys instead (mise, brew, apt-get, manual, etc.).
     Platform keys are ignored by the installer.
```

**Correct Usage**:

```yaml
# ✅ CORRECT - Installer-kind keys with priority
tools:
  ripgrep:
    platforms: ["linux", "darwin", "windows"]
    installer_priority:
      linux: ["mise", "apt-get"]
      darwin: ["mise", "brew"]
      windows: ["mise", "scoop"]
    install_commands:
      mise: "mise use -g ripgrep@latest"
      apt-get: "sudo apt-get install -y ripgrep"
      brew: "brew install ripgrep"
      scoop: "scoop install ripgrep"
```

**Impact**:
- ✅ Users will see warnings when using wrong keys
- ✅ All documentation now consistently shows correct patterns
- ✅ Explains why installer-kind approach is better (flexible, platform-independent, priority control)

**Files Modified**:
- `internal/doctor/tools.go`: Added `ValidateInstallerCommands()` with platform detection (42 LOC)
- `docs/appnotes/lib/tools.md`: Added 80 lines of installer-kinds explanation + corrected examples
- `docs/appnotes/tools-runner-usage.md`: Fixed 3 examples to use installer-kind keys
- `docs/user-guide/bootstrap/package-managers.md`: Added 50 lines on automatic bootstrap with mise example

## What's Changed

### Test Infrastructure: Root Factory Pattern for Cobra Command Isolation

Implemented a comprehensive solution to eliminate test isolation failures caused by shared Cobra command state. This infrastructure change ensures all tests pass reliably in both isolation and full suite runs.

**Problem**: 16 tests passed when run individually but failed in full suite (`go test ./...`), exhibiting classic symptoms of state pollution:

- Tests in `cmd/` shared the package-level `rootCmd` singleton
- Flag values, args, and logger state persisted between tests
- Test results varied based on execution order
- Subcommand singletons (`doctorCmd`, `infoCmd`, etc.) retained flag values across tests

**Root Cause**: Cobra's idiomatic pattern encourages package-level command declarations for clean CLI structure. When tests shared these singletons, state from one test "leaked" into subsequent tests, causing non-deterministic failures.

**Solution - Root Factory Pattern**:

1. **Command Factory**: Created `newRootCommand()` factory function that returns fresh `cobra.Command` instances per test, preventing command tree state pollution

2. **Centralized Registration**: Added `registerSubcommands()` helper for centralized subcommand registration, replacing scattered `rootCmd.AddCommand()` calls in `init()` functions

3. **Flag Variable Reset**: Updated test helpers to reset package-level flag variables before each test execution

4. **Subcommand Flag Reset**: Added flag value resets for package-level subcommand singletons when needed

**Implementation**:

```go
// cmd/root.go
func newRootCommand() *cobra.Command {
    cmd := &cobra.Command{
        Use: "goneat",
        // ... full command setup
    }
    // Add persistent flags
    cmd.PersistentFlags().String("log-level", "info", "...")
    // ...
    return cmd
}

func registerSubcommands(cmd *cobra.Command) {
    cmd.AddCommand(versionCmd)
    cmd.AddCommand(formatCmd)
    // ... all subcommands
}

// Production rootCmd still uses singleton
var rootCmd = newRootCommand()

func init() {
    registerSubcommands(rootCmd)
}

// Tests use fresh instances
func execDoctorTools(t *testing.T, args []string) (string, error) {
    // Reset package-level flags
    flagDoctorInstall = false
    flagDoctorScope = "security"
    // ...

    // Create fresh command
    cmd := newRootCommand()
    registerSubcommands(cmd)

    cmd.SetArgs(append([]string{"doctor", "tools"}, args...))
    return executeCommand(cmd)
}
```

**Impact**:

- ✅ **0 Test Failures**: All 16 previously-failing tests now pass in full suite
- ✅ **Deterministic**: Test results no longer depend on execution order
- ✅ **Parallel Safety**: Tests can run in parallel without interference
- ✅ **CI/CD Reliability**: Multi-platform pipelines get consistent results
- ✅ **Maintainability**: Pattern is documented for future test development

**Pattern Documentation**:

Created comprehensive guide at `.plans/memos/crucible/cobra-test-isolation-pattern.md` for Crucible adoption:

- Problem statement with symptoms and root cause analysis
- Step-by-step implementation guide with code examples
- Troubleshooting section for common issues
- Trade-offs and alternative approaches
- Real-world example from goneat v0.3.6
- Implementation checklist
- Recommended for Arch Eagle review and inclusion in Crucible's Go testing guide

**Files Modified**:
- `cmd/root.go`: Added `newRootCommand()` factory and `registerSubcommands()` helper (75 LOC)
- `cmd/doctor_test.go`: Updated `execDoctorTools()` to use factory pattern with flag resets
- `cmd/envinfo_test.go`: Updated `execRoot()` to use factory pattern
- `cmd/info_test.go`: Updated `execInfoLicenses()` with subcommand flag resets
- `cmd/root_test.go`: Updated all root command tests to use factory pattern
- `.plans/memos/crucible/cobra-test-isolation-pattern.md`: Comprehensive pattern documentation (330 LOC)

**Test Results**:

```bash
# Before: 16 failures in full suite, 0 in isolation
go test ./cmd/...
# FAIL: TestEnvinfo_JSON, TestPathfinderFindJSON, TestInfoLicenses_JSONFlag, ...

# After: 0 failures in both modes
go test ./cmd/...
# PASS: All tests (100% success rate)
```

## Breaking Changes

None. This is a purely additive feature.

## Known Limitations

- **Auto-Install**: Package manager auto-installation (`--install-package-managers`) shows manual instructions but does not execute automatic installation. This is intentional for security and will be considered for v0.3.7+ based on user feedback.
- **Manager Support**: Currently supports Homebrew and Scoop. Other package managers (apt, dnf, winget) may be added in future releases.

## Upgrade Guide

No changes required. Existing configurations continue to work. To adopt package manager installations:

1. Update your `.goneat/tools.yaml` to use v1.1.0 schema
2. Replace `install_commands` with `install.package_manager` configuration
3. Run `goneat doctor tools --validate-config` to verify
4. Test with `--dry-run` before production use

See `.goneat/examples/` for reference configurations.

## Installation

```bash
# Go install (recommended)
go install github.com/fulmenhq/goneat@v0.3.6

# Homebrew (macOS/Linux)
brew upgrade goneat

# Verify installation
goneat version
```

## What's Next (v0.3.7+)

- Dependency vulnerability scanning integration
- Package manager auto-install enhancement (optional)
- Additional language support (TypeScript, Python) in v0.4.x
