
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>finalizer: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/3leaps/goneat/pkg/format/finalizer/finalizer.go (95.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">/*
Copyright Â© 2025 3 Leaps &lt;info@3leaps.net&gt;
*/
package finalizer

import (
        "bytes"
        "strings"
        "unicode/utf8"
)

// NormalizeEOF normalizes the end-of-file formatting of the given content
func NormalizeEOF(input []byte, ensure bool, collapse bool, trimTrailingSpaces bool, lineEnding string) (out []byte, changed bool, err error) <span class="cov8" title="1">{
        if len(input) == 0 </span><span class="cov8" title="1">{
                return input, false, nil
        }</span>

        // Check if content is processable text
        <span class="cov8" title="1">if !IsProcessableText(input) </span><span class="cov0" title="0">{
                return input, false, nil
        }</span>

        // Convert to string for easier processing
        <span class="cov8" title="1">content := string(input)
        originalContent := content
        lines := strings.Split(content, "\n")

        // Determine the line ending style used in the file
        if lineEnding == "" </span><span class="cov8" title="1">{
                lineEnding = detectLineEnding(content)
        }</span>

        // Process each line
        <span class="cov8" title="1">for i, line := range lines </span><span class="cov8" title="1">{
                // Trim trailing whitespace if requested
                if trimTrailingSpaces </span><span class="cov8" title="1">{
                        trimmed := strings.TrimRight(line, " \t")
                        if trimmed != line </span><span class="cov8" title="1">{
                                lines[i] = trimmed
                                changed = true
                        }</span>
                }
        }

        // Rejoin lines with detected line ending
        <span class="cov8" title="1">content = strings.Join(lines, lineEnding)

        // Handle EOF newline normalization
        if ensure </span><span class="cov8" title="1">{
                // Ensure the file ends with exactly one newline
                content = ensureSingleTrailingNewline(content, lineEnding)
        }</span> else<span class="cov8" title="1"> if collapse </span><span class="cov8" title="1">{
                // Just collapse multiple trailing newlines to one (if any)
                content = collapseTrailingNewlines(content, lineEnding)
        }</span>

        // Check if anything changed
        <span class="cov8" title="1">if content != originalContent </span><span class="cov8" title="1">{
                changed = true
        }</span>

        <span class="cov8" title="1">return []byte(content), changed, nil</span>
}

// NormalizeWhitespace removes trailing whitespace from all lines and normalizes EOF
func NormalizeWhitespace(input []byte, ensureEOF bool, lineEnding string) (out []byte, changed bool, err error) <span class="cov8" title="1">{
        return NormalizeEOF(input, ensureEOF, true, true, lineEnding)
}</span>

// NormalizeLineEndings converts all line endings to the specified style
func NormalizeLineEndings(input []byte, targetEnding string) (out []byte, changed bool, err error) <span class="cov8" title="1">{
        if len(input) == 0 </span><span class="cov8" title="1">{
                return input, false, nil
        }</span>

        // Check for binary content
        <span class="cov8" title="1">if bytes.Contains(input, []byte{0}) </span><span class="cov8" title="1">{
                return input, false, nil
        }</span>

        <span class="cov8" title="1">content := string(input)
        originalContent := content

        // Normalize line endings
        content = strings.ReplaceAll(content, "\r\n", "\n") // CRLF -&gt; LF
        content = strings.ReplaceAll(content, "\r", "\n")   // CR -&gt; LF

        // Convert to target ending if specified
        if targetEnding == "\r\n" </span><span class="cov8" title="1">{
                content = strings.ReplaceAll(content, "\n", "\r\n")
        }</span>

        <span class="cov8" title="1">if content != originalContent </span><span class="cov8" title="1">{
                changed = true
        }</span>

        <span class="cov8" title="1">return []byte(content), changed, nil</span>
}

// RemoveUTF8BOM removes UTF-8 Byte Order Mark if present
func RemoveUTF8BOM(input []byte) (out []byte, changed bool, err error) <span class="cov8" title="1">{
        if len(input) &gt;= 3 &amp;&amp; bytes.HasPrefix(input, []byte{0xEF, 0xBB, 0xBF}) </span><span class="cov8" title="1">{
                return input[3:], true, nil
        }</span>
        <span class="cov8" title="1">return input, false, nil</span>
}

// RemoveBOM removes Byte Order Mark of any supported encoding if present
func RemoveBOM(input []byte) (out []byte, changed bool, err error) <span class="cov8" title="1">{
        if len(input) == 0 </span><span class="cov8" title="1">{
                return input, false, nil
        }</span>

        // Check for UTF-32BE BOM (4 bytes)
        <span class="cov8" title="1">if len(input) &gt;= 4 &amp;&amp; bytes.HasPrefix(input, []byte{0x00, 0x00, 0xFE, 0xFF}) </span><span class="cov8" title="1">{
                return input[4:], true, nil
        }</span>

        // Check for UTF-32LE BOM (4 bytes)
        <span class="cov8" title="1">if len(input) &gt;= 4 &amp;&amp; bytes.HasPrefix(input, []byte{0xFF, 0xFE, 0x00, 0x00}) </span><span class="cov8" title="1">{
                return input[4:], true, nil
        }</span>

        // Check for UTF-8 BOM (3 bytes)
        <span class="cov8" title="1">if len(input) &gt;= 3 &amp;&amp; bytes.HasPrefix(input, []byte{0xEF, 0xBB, 0xBF}) </span><span class="cov8" title="1">{
                return input[3:], true, nil
        }</span>

        // Check for UTF-16BE BOM (2 bytes)
        <span class="cov8" title="1">if len(input) &gt;= 2 &amp;&amp; bytes.HasPrefix(input, []byte{0xFE, 0xFF}) </span><span class="cov8" title="1">{
                return input[2:], true, nil
        }</span>

        // Check for UTF-16LE BOM (2 bytes)
        <span class="cov8" title="1">if len(input) &gt;= 2 &amp;&amp; bytes.HasPrefix(input, []byte{0xFF, 0xFE}) </span><span class="cov8" title="1">{
                return input[2:], true, nil
        }</span>

        <span class="cov8" title="1">return input, false, nil</span>
}

// GetBOMInfo returns information about detected BOM
func GetBOMInfo(input []byte) (encoding string, bomSize int, found bool) <span class="cov8" title="1">{
        if len(input) == 0 </span><span class="cov8" title="1">{
                return "", 0, false
        }</span>

        // Check for UTF-32BE BOM
        <span class="cov8" title="1">if len(input) &gt;= 4 &amp;&amp; bytes.HasPrefix(input, []byte{0x00, 0x00, 0xFE, 0xFF}) </span><span class="cov8" title="1">{
                return "UTF-32BE", 4, true
        }</span>

        // Check for UTF-32LE BOM
        <span class="cov8" title="1">if len(input) &gt;= 4 &amp;&amp; bytes.HasPrefix(input, []byte{0xFF, 0xFE, 0x00, 0x00}) </span><span class="cov8" title="1">{
                return "UTF-32LE", 4, true
        }</span>

        // Check for UTF-8 BOM
        <span class="cov8" title="1">if len(input) &gt;= 3 &amp;&amp; bytes.HasPrefix(input, []byte{0xEF, 0xBB, 0xBF}) </span><span class="cov8" title="1">{
                return "UTF-8", 3, true
        }</span>

        // Check for UTF-16BE BOM
        <span class="cov8" title="1">if len(input) &gt;= 2 &amp;&amp; bytes.HasPrefix(input, []byte{0xFE, 0xFF}) </span><span class="cov8" title="1">{
                return "UTF-16BE", 2, true
        }</span>

        // Check for UTF-16LE BOM
        <span class="cov8" title="1">if len(input) &gt;= 2 &amp;&amp; bytes.HasPrefix(input, []byte{0xFF, 0xFE}) </span><span class="cov8" title="1">{
                return "UTF-16LE", 2, true
        }</span>

        <span class="cov8" title="1">return "", 0, false</span>
}

// ComprehensiveFileNormalization applies all normalization operations
func ComprehensiveFileNormalization(input []byte, options NormalizationOptions) (out []byte, changed bool, err error) <span class="cov8" title="1">{
        // Check if content is processable text
        if !IsProcessableText(input) </span><span class="cov0" title="0">{
                return input, false, nil
        }</span>

        <span class="cov8" title="1">content := input
        totalChanged := false

        // Remove BOM if requested (supports UTF-8, UTF-16, UTF-32)
        if options.RemoveUTF8BOM </span><span class="cov8" title="1">{
                if result, hasChanged, err := RemoveBOM(content); err != nil </span><span class="cov0" title="0">{
                        return nil, false, err
                }</span> else<span class="cov8" title="1"> if hasChanged </span><span class="cov8" title="1">{
                        content = result
                        totalChanged = true
                }</span>
        }

        // Normalize line endings if requested
        <span class="cov8" title="1">if options.NormalizeLineEndings != "" </span><span class="cov8" title="1">{
                if result, hasChanged, err := NormalizeLineEndings(content, options.NormalizeLineEndings); err != nil </span><span class="cov0" title="0">{
                        return nil, false, err
                }</span> else<span class="cov8" title="1"> if hasChanged </span><span class="cov8" title="1">{
                        content = result
                        totalChanged = true
                }</span>
        }

        // Apply EOF and whitespace normalization
        <span class="cov8" title="1">if result, hasChanged, err := NormalizeEOF(content, options.EnsureEOF, true, options.TrimTrailingWhitespace, ""); err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span> else<span class="cov8" title="1"> if hasChanged </span><span class="cov8" title="1">{
                content = result
                totalChanged = true
        }</span>

        <span class="cov8" title="1">return content, totalChanged, nil</span>
}

// NormalizationOptions configures file normalization behavior
type NormalizationOptions struct {
        EnsureEOF              bool   // Ensure file ends with exactly one newline
        TrimTrailingWhitespace bool   // Remove trailing spaces/tabs from all lines
        NormalizeLineEndings   string // Target line ending style ("", "\n", or "\r\n")
        RemoveUTF8BOM          bool   // Remove Byte Order Mark (UTF-8, UTF-16, UTF-32)
}

// detectLineEnding detects the primary line ending style used in the content
func detectLineEnding(content string) string <span class="cov8" title="1">{
        // Count LF and CRLF occurrences
        lfCount := strings.Count(content, "\n") - strings.Count(content, "\r\n")
        crlfCount := strings.Count(content, "\r\n")

        // Use the more common line ending, default to LF
        if crlfCount &gt; lfCount </span><span class="cov8" title="1">{
                return "\r\n"
        }</span>
        <span class="cov8" title="1">return "\n"</span>
}

// ensureSingleTrailingNewline ensures the content ends with exactly one newline
func ensureSingleTrailingNewline(content, lineEnding string) string <span class="cov8" title="1">{
        // First, collapse any existing trailing newlines
        content = collapseTrailingNewlines(content, lineEnding)

        // Then ensure it ends with exactly one
        if !strings.HasSuffix(content, lineEnding) </span><span class="cov8" title="1">{
                content += lineEnding
        }</span>

        <span class="cov8" title="1">return content</span>
}

// collapseTrailingNewlines collapses multiple trailing newlines to a single one
func collapseTrailingNewlines(content, lineEnding string) string <span class="cov8" title="1">{
        // Remove all trailing whitespace including newlines
        content = strings.TrimRight(content, " \t\r\n")

        // Add back a single newline if the original had any trailing newlines
        // We determine this by checking if the original content had trailing newlines
        originalLen := len(content)
        trimmed := strings.TrimRight(content, "\r\n")
        if originalLen &gt; len(trimmed) </span><span class="cov0" title="0">{
                content = trimmed + lineEnding
        }</span>

        <span class="cov8" title="1">return content</span>
}

// IsTextFile performs a heuristic check to determine if content is likely text
func IsTextFile(content []byte) bool <span class="cov8" title="1">{
        if len(content) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        // Check for NUL bytes (binary file indicator)
        <span class="cov8" title="1">if bytes.Contains(content, []byte{0}) </span><span class="cov8" title="1">{
                return false
        }</span>

        // Check if content is valid UTF-8
        <span class="cov8" title="1">return utf8.Valid(content)</span>
}

// IsProcessableText performs a more sophisticated check for text that can be processed
// This allows UTF-16/UTF-32 files with BOMs to be processed
func IsProcessableText(content []byte) bool <span class="cov8" title="1">{
        if len(content) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        // Allow files with BOMs (UTF-8, UTF-16, UTF-32)
        <span class="cov8" title="1">if HasBOM(content) </span><span class="cov8" title="1">{
                // Remove BOM and check if the rest is processable
                _, _, found := GetBOMInfo(content)
                if found </span><span class="cov8" title="1">{
                        // For UTF-16/UTF-32, we can still process if it's text-like
                        // For now, allow UTF-16/UTF-32 with BOMs
                        return true
                }</span>
        }

        // Check for excessive NUL bytes (likely binary)
        <span class="cov8" title="1">nulCount := bytes.Count(content, []byte{0})
        if nulCount &gt; len(content)/10 </span><span class="cov8" title="1">{ // More than 10% NUL bytes
                return false
        }</span>

        // Check if content is valid UTF-8 (after potential BOM removal)
        <span class="cov8" title="1">contentWithoutBOM := RemoveBOMSafe(content)
        return utf8.Valid(contentWithoutBOM)</span>
}

// HasBOM checks if the content starts with a known BOM
func HasBOM(content []byte) bool <span class="cov8" title="1">{
        _, _, found := GetBOMInfo(content)
        return found
}</span>

// RemoveBOMSafe removes BOM if present, returns original content if not
func RemoveBOMSafe(content []byte) []byte <span class="cov8" title="1">{
        result, _, _ := RemoveBOM(content)
        return result
}</span>

// GetSupportedExtensions returns the list of file extensions supported by the finalizer
func GetSupportedExtensions() []string <span class="cov8" title="1">{
        return []string{
                ".go",
                ".yaml", ".yml",
                ".json",
                ".md", ".markdown",
                ".txt",
                ".sh",
                ".py",
                ".js", ".jsx", ".ts", ".tsx",
                ".html", ".htm",
                ".css",
                ".xml",
                ".toml",
                ".ini",
                ".cfg",
                ".conf",
        }
}</span>

// IsSupportedExtension checks if the given file extension is supported by the finalizer
func IsSupportedExtension(ext string) bool <span class="cov8" title="1">{
        ext = strings.ToLower(ext)
        supported := GetSupportedExtensions()
        for _, supportedExt := range supported </span><span class="cov8" title="1">{
                if ext == supportedExt </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
