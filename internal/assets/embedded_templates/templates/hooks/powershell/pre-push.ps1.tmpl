# PowerShell hook template for goneat pre-push validation
# Generated by goneat hooks generate
# Schema-compliant hook template (PowerShell)

param(
    [string]$HookManifest = "$PSScriptRoot\.goneat\hooks.yaml",
    [switch]$StagedOnly = $false,
    [switch]$Verbose = $false
)

# Set error action preference
$ErrorActionPreference = "Stop"

# Resolve repository root for reliable relative paths
$REPO_ROOT = git rev-parse --show-toplevel 2>$null
if ($LASTEXITCODE -ne 0) {
    $REPO_ROOT = Get-Location
}

# Resolve goneat home for ephemeral artifacts (reports/cache/tmp)
# Repo .goneat/ is static-only; do not write reports here.
$GONEAT_HOME = if ($env:GONEAT_HOME) { $env:GONEAT_HOME } else { "$env:USERPROFILE\.goneat" }
$env:GONEAT_HOME = $GONEAT_HOME

# Detect dev mode: enabled if .goneat/dev-mode exists or env is set
$DEV_MODE = $false
if ((Test-Path "$REPO_ROOT\.goneat\dev-mode") -or ($env:GONEAT_DEV_MODE -eq "1")) {
    $DEV_MODE = $true
}

Write-Host "üöÄ Running goneat pre-push validation..."

# Robust binary discovery (prefer repo build first, then PATH/common locations)
function Find-GoneatBinary {
    # Check repo dist directory
    if (Test-Path "$REPO_ROOT\dist\goneat.exe") {
        return "$REPO_ROOT\dist\goneat.exe"
    }
    if (Test-Path "$REPO_ROOT\dist\goneat") {
        return "$REPO_ROOT\dist\goneat"
    }

    # Check common locations
    $candidates = @(
        "$env:GOPATH\bin\goneat.exe",
        "$env:GOPATH\bin\goneat",
        "$env:USERPROFILE\go\bin\goneat.exe",
        "$env:USERPROFILE\go\bin\goneat",
        "$env:USERPROFILE\.local\bin\goneat.exe",
        "$env:USERPROFILE\.local\bin\goneat",
        "$env:USERPROFILE\.goneat\bin\goneat.exe",
        "$env:USERPROFILE\.goneat\bin\goneat",
        "goneat.exe",
        "goneat"
    )

    foreach ($candidate in $candidates) {
        if (Test-Path $candidate) {
            return $candidate
        }
        # Also try command discovery
        try {
            $null = Get-Command $candidate -ErrorAction Stop
            return $candidate
        } catch {
            continue
        }
    }

    return $null
}

$GONEAT_BIN = Find-GoneatBinary

if (-not $GONEAT_BIN) {
    if ($DEV_MODE) {
        Write-Host "‚ö†Ô∏è  goneat not found (dev mode). Using fallback validation"
        {{- if .Fallback }}
        {{ .Fallback }}
        {{- else }}
        Write-Host "Skipping validation - goneat not available"
        {{- end }}
        exit 0
    } else {
        Write-Host "‚ùå goneat CLI not found. Pre-push validation requires goneat."
        Write-Host "üëâ Install options:"
        Write-Host "   - Go:   go install github.com/fulmenhq/goneat@latest"
        Write-Host "   - Scoop: scoop install goneat"
        Write-Host "   - Releases: https://github.com/fulmenhq/goneat/releases"
        Write-Host "üîé Searched: $REPO_ROOT\dist, $env:GOPATH\bin, $env:USERPROFILE\go\bin, $env:USERPROFILE\.local\bin, $env:USERPROFILE\.goneat\bin"
        Write-Host "üí° Tip: Ensure Go bin directory is in PATH"
        exit 1
    }
}

# Guardian enforcement for protected git push operations
{{- if .Guardian.Enabled }}
$RemoteName = if ($args.Length -ge 1) { $args[0] } else { "" }
$RemoteUrl = if ($args.Length -ge 2) { $args[1] } else { "" }
$CurrentBranch = git rev-parse --abbrev-ref HEAD 2>$null
if ($LASTEXITCODE -ne 0) {
    $CurrentBranch = ""
}

$GuardianScope = "{{ .Guardian.Scope }}"
$GuardianOperation = "{{ .Guardian.Operation }}"
$guardianArgs = @("guardian", "check", $GuardianScope, $GuardianOperation)
if ($CurrentBranch) {
    $guardianArgs += @("--branch", $CurrentBranch)
}
if ($RemoteName) {
    $guardianArgs += @("--remote", $RemoteName)
} elseif ($RemoteUrl) {
    $guardianArgs += @("--remote", $RemoteUrl)
}

& $GONEAT_BIN @guardianArgs | Out-Null
if ($LASTEXITCODE -ne 0) {
    Write-Host ""
    Write-Host "‚ùå Operation blocked by guardian"
    Write-Host "üîê Approval required for: $GuardianScope $GuardianOperation"
    if ($CurrentBranch) {
        Write-Host "   ‚Ä¢ Branch: $CurrentBranch"
    }
    if ($RemoteName) {
        Write-Host "   ‚Ä¢ Remote: $RemoteName"
    } elseif ($RemoteUrl) {
        Write-Host "   ‚Ä¢ Remote URL: $RemoteUrl"
    }
    {{- if .Guardian.Risk }}
    Write-Host "   ‚Ä¢ Risk level: {{ .Guardian.Risk }}"
    {{- end }}
    {{- if .Guardian.Method }}
    Write-Host "   ‚Ä¢ Method: {{ .Guardian.Method }}"
    {{- end }}
    {{- if .Guardian.Expires }}
    Write-Host "   ‚Ä¢ Approval expires in: {{ .Guardian.Expires }}"
    {{- end }}
    {{- if .Guardian.RequireReason }}
    Write-Host "üìù A reason is required when approving this operation."
    {{- end }}
    Write-Host ""
    Write-Host "Wrap your git push with guardian approval to proceed:"
    if ($RemoteName -and $CurrentBranch) {
        Write-Host "  $GONEAT_BIN guardian approve $GuardianScope $GuardianOperation -- git push \"$RemoteName\" \"$CurrentBranch\""
    } elseif ($RemoteUrl -and $CurrentBranch) {
        Write-Host "  $GONEAT_BIN guardian approve $GuardianScope $GuardianOperation -- git push \"$RemoteUrl\" \"$CurrentBranch\""
    } else {
        Write-Host "  $GONEAT_BIN guardian approve $GuardianScope $GuardianOperation -- git push <remote> <branch>"
    }
    Write-Host "Once approved, the push runs automatically under guardian supervision."
    exit 1
}

Write-Host "‚úÖ Guardian approval satisfied"
{{- end }}

# Use goneat's orchestrated assessment (manifest-driven)
$args = @(
    "assess",
    "--hook", "pre-push",
    "--hook-manifest", "$REPO_ROOT\.goneat\hooks.yaml"
)

if ($StagedOnly) {
    $args += "--staged-only"
}

{{- range .Args }}
$args += "{{ . }}"
{{- end }}

& $GONEAT_BIN @args

if ($LASTEXITCODE -ne 0) {
    exit $LASTEXITCODE
}

Write-Host "‚úÖ Pre-push validation passed!"
